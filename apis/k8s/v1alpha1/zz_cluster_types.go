/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AutoUpgradeObservation struct {
}

type AutoUpgradeParameters struct {

	// Enables the Kubernetes patch version auto upgrade
	// +kubebuilder:validation:Required
	Enable *bool `json:"enable" tf:"enable,omitempty"`

	// Day of the maintenance window
	// +kubebuilder:validation:Required
	MaintenanceWindowDay *string `json:"maintenanceWindowDay" tf:"maintenance_window_day,omitempty"`

	// Start hour of the 2-hour maintenance window
	// +kubebuilder:validation:Required
	MaintenanceWindowStartHour *float64 `json:"maintenanceWindowStartHour" tf:"maintenance_window_start_hour,omitempty"`
}

type AutoscalerConfigObservation struct {
}

type AutoscalerConfigParameters struct {

	// Detect similar node groups and balance the number of nodes between them
	// +kubebuilder:validation:Optional
	BalanceSimilarNodeGroups *bool `json:"balanceSimilarNodeGroups,omitempty" tf:"balance_similar_node_groups,omitempty"`

	// Disable the scale down feature of the autoscaler
	// +kubebuilder:validation:Optional
	DisableScaleDown *bool `json:"disableScaleDown,omitempty" tf:"disable_scale_down,omitempty"`

	// Type of resource estimator to be used in scale up
	// +kubebuilder:validation:Optional
	Estimator *string `json:"estimator,omitempty" tf:"estimator,omitempty"`

	// Type of node group expander to be used in scale up
	// +kubebuilder:validation:Optional
	Expander *string `json:"expander,omitempty" tf:"expander,omitempty"`

	// Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable
	// +kubebuilder:validation:Optional
	ExpendablePodsPriorityCutoff *float64 `json:"expendablePodsPriorityCutoff,omitempty" tf:"expendable_pods_priority_cutoff,omitempty"`

	// Ignore DaemonSet pods when calculating resource utilization for scaling down
	// +kubebuilder:validation:Optional
	IgnoreDaemonsetsUtilization *bool `json:"ignoreDaemonsetsUtilization,omitempty" tf:"ignore_daemonsets_utilization,omitempty"`

	// Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
	// +kubebuilder:validation:Optional
	MaxGracefulTerminationSec *float64 `json:"maxGracefulTerminationSec,omitempty" tf:"max_graceful_termination_sec,omitempty"`

	// How long after scale up that scale down evaluation resumes
	// +kubebuilder:validation:Optional
	ScaleDownDelayAfterAdd *string `json:"scaleDownDelayAfterAdd,omitempty" tf:"scale_down_delay_after_add,omitempty"`

	// How long a node should be unneeded before it is eligible for scale down
	// +kubebuilder:validation:Optional
	ScaleDownUnneededTime *string `json:"scaleDownUnneededTime,omitempty" tf:"scale_down_unneeded_time,omitempty"`

	// Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
	// +kubebuilder:validation:Optional
	ScaleDownUtilizationThreshold *float64 `json:"scaleDownUtilizationThreshold,omitempty" tf:"scale_down_utilization_threshold,omitempty"`
}

type ClusterObservation struct {

	// Kubernetes API server URL
	ApiserverURL *string `json:"apiserverUrl,omitempty" tf:"apiserver_url,omitempty"`

	// The date and time of the creation of the Kubernetes cluster
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The kubeconfig configuration file of the Kubernetes cluster
	Kubeconfig []KubeconfigObservation `json:"kubeconfig,omitempty" tf:"kubeconfig,omitempty"`

	// The organization_id you want to attach the resource to
	OrganizationID *string `json:"organizationId,omitempty" tf:"organization_id,omitempty"`

	// The status of the cluster
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// The date and time of the last update of the Kubernetes cluster
	UpdatedAt *string `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`

	// True if an upgrade is available
	UpgradeAvailable *bool `json:"upgradeAvailable,omitempty" tf:"upgrade_available,omitempty"`

	// Wildcard DNS pointing to all the ready nodes
	WildcardDNS *string `json:"wildcardDns,omitempty" tf:"wildcard_dns,omitempty"`
}

type ClusterParameters struct {

	// The list of admission plugins to enable on the cluster
	// +kubebuilder:validation:Optional
	AdmissionPlugins []*string `json:"admissionPlugins,omitempty" tf:"admission_plugins,omitempty"`

	// Additional Subject Alternative Names for the Kubernetes API server certificate
	// +kubebuilder:validation:Optional
	ApiserverCertSans []*string `json:"apiserverCertSans,omitempty" tf:"apiserver_cert_sans,omitempty"`

	// The auto upgrade configuration for the cluster
	// +kubebuilder:validation:Optional
	AutoUpgrade []AutoUpgradeParameters `json:"autoUpgrade,omitempty" tf:"auto_upgrade,omitempty"`

	// The autoscaler configuration for the cluster
	// +kubebuilder:validation:Optional
	AutoscalerConfig []AutoscalerConfigParameters `json:"autoscalerConfig,omitempty" tf:"autoscaler_config,omitempty"`

	// The CNI plugin of the cluster
	// +kubebuilder:validation:Required
	Cni *string `json:"cni" tf:"cni,omitempty"`

	// Delete additional resources like block volumes and loadbalancers on cluster deletion
	// +kubebuilder:validation:Optional
	DeleteAdditionalResources *bool `json:"deleteAdditionalResources,omitempty" tf:"delete_additional_resources,omitempty"`

	// The description of the cluster
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The list of feature gates to enable on the cluster
	// +kubebuilder:validation:Optional
	FeatureGates []*string `json:"featureGates,omitempty" tf:"feature_gates,omitempty"`

	// The name of the cluster
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// The OpenID Connect configuration of the cluster
	// +kubebuilder:validation:Optional
	OpenIDConnectConfig []OpenIDConnectConfigParameters `json:"openIdConnectConfig,omitempty" tf:"open_id_connect_config,omitempty"`

	// The project_id you want to attach the resource to
	// +kubebuilder:validation:Optional
	ProjectID *string `json:"projectId,omitempty" tf:"project_id,omitempty"`

	// The region you want to attach the resource to
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// The tags associated with the cluster
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The type of cluster
	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`

	// The version of the cluster
	// +kubebuilder:validation:Required
	Version *string `json:"version" tf:"version,omitempty"`
}

type KubeconfigObservation struct {
	ClusterCACertificate *string `json:"clusterCaCertificate,omitempty" tf:"cluster_ca_certificate,omitempty"`

	ConfigFile *string `json:"configFile,omitempty" tf:"config_file,omitempty"`

	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	Token *string `json:"token,omitempty" tf:"token,omitempty"`
}

type KubeconfigParameters struct {
}

type OpenIDConnectConfigObservation struct {
}

type OpenIDConnectConfigParameters struct {

	// A client id that all tokens must be issued for
	// +kubebuilder:validation:Required
	ClientID *string `json:"clientId" tf:"client_id,omitempty"`

	// JWT claim to use as the user's group
	// +kubebuilder:validation:Optional
	GroupsClaim []*string `json:"groupsClaim,omitempty" tf:"groups_claim,omitempty"`

	// Prefix prepended to group claims
	// +kubebuilder:validation:Optional
	GroupsPrefix *string `json:"groupsPrefix,omitempty" tf:"groups_prefix,omitempty"`

	// URL of the provider which allows the API server to discover public signing keys
	// +kubebuilder:validation:Required
	IssuerURL *string `json:"issuerUrl" tf:"issuer_url,omitempty"`

	// Multiple key=value pairs that describes a required claim in the ID Token
	// +kubebuilder:validation:Optional
	RequiredClaim []*string `json:"requiredClaim,omitempty" tf:"required_claim,omitempty"`

	// JWT claim to use as the user name
	// +kubebuilder:validation:Optional
	UsernameClaim *string `json:"usernameClaim,omitempty" tf:"username_claim,omitempty"`

	// Prefix prepended to username
	// +kubebuilder:validation:Optional
	UsernamePrefix *string `json:"usernamePrefix,omitempty" tf:"username_prefix,omitempty"`
}

// ClusterSpec defines the desired state of Cluster
type ClusterSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ClusterParameters `json:"forProvider"`
}

// ClusterStatus defines the observed state of Cluster.
type ClusterStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ClusterObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Cluster is the Schema for the Clusters API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,scaleway}
type Cluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ClusterSpec   `json:"spec"`
	Status            ClusterStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ClusterList contains a list of Clusters
type ClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Cluster `json:"items"`
}

// Repository type metadata.
var (
	Cluster_Kind             = "Cluster"
	Cluster_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Cluster_Kind}.String()
	Cluster_KindAPIVersion   = Cluster_Kind + "." + CRDGroupVersion.String()
	Cluster_GroupVersionKind = CRDGroupVersion.WithKind(Cluster_Kind)
)

func init() {
	SchemeBuilder.Register(&Cluster{}, &ClusterList{})
}
