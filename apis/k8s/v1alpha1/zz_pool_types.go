/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type NodesObservation struct {
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	PublicIP *string `json:"publicIp,omitempty" tf:"public_ip,omitempty"`

	PublicIPV6 *string `json:"publicIpV6,omitempty" tf:"public_ip_v6,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type NodesParameters struct {
}

type PoolObservation struct {

	// The date and time of the creation of the pool
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// The actual size of the pool
	CurrentSize *float64 `json:"currentSize,omitempty" tf:"current_size,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Nodes []NodesObservation `json:"nodes,omitempty" tf:"nodes,omitempty"`

	// The status of the pool
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// The date and time of the last update of the pool
	UpdatedAt *string `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`

	// The Kubernetes version of the pool
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type PoolParameters struct {

	// Enable the autohealing on the pool
	// +kubebuilder:validation:Optional
	Autohealing *bool `json:"autohealing,omitempty" tf:"autohealing,omitempty"`

	// Enable the autoscaling on the pool
	// +kubebuilder:validation:Optional
	Autoscaling *bool `json:"autoscaling,omitempty" tf:"autoscaling,omitempty"`

	// The ID of the cluster on which this pool will be created
	// +crossplane:generate:reference:type=Cluster
	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Reference to a Cluster to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDRef *v1.Reference `json:"clusterIdRef,omitempty" tf:"-"`

	// Selector for a Cluster to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDSelector *v1.Selector `json:"clusterIdSelector,omitempty" tf:"-"`

	// Container runtime for the pool
	// +kubebuilder:validation:Optional
	ContainerRuntime *string `json:"containerRuntime,omitempty" tf:"container_runtime,omitempty"`

	// The Kubelet arguments to be used by this pool
	// +kubebuilder:validation:Optional
	KubeletArgs map[string]*string `json:"kubeletArgs,omitempty" tf:"kubelet_args,omitempty"`

	// Maximum size of the pool
	// +kubebuilder:validation:Optional
	MaxSize *float64 `json:"maxSize,omitempty" tf:"max_size,omitempty"`

	// Minimum size of the pool
	// +kubebuilder:validation:Optional
	MinSize *float64 `json:"minSize,omitempty" tf:"min_size,omitempty"`

	// The name of the cluster
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// Server type of the pool servers
	// +kubebuilder:validation:Required
	NodeType *string `json:"nodeType" tf:"node_type,omitempty"`

	// ID of the placement group
	// +kubebuilder:validation:Optional
	PlacementGroupID *string `json:"placementGroupId,omitempty" tf:"placement_group_id,omitempty"`

	// The region you want to attach the resource to
	// +kubebuilder:validation:Optional
	Region *string `json:"region,omitempty" tf:"region,omitempty"`

	// The size of the system volume of the nodes in gigabyte
	// +kubebuilder:validation:Optional
	RootVolumeSizeInGb *float64 `json:"rootVolumeSizeInGb,omitempty" tf:"root_volume_size_in_gb,omitempty"`

	// System volume type of the nodes composing the pool
	// +kubebuilder:validation:Optional
	RootVolumeType *string `json:"rootVolumeType,omitempty" tf:"root_volume_type,omitempty"`

	// Size of the pool
	// +kubebuilder:validation:Required
	Size *float64 `json:"size" tf:"size,omitempty"`

	// The tags associated with the pool
	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// The Pool upgrade policy
	// +kubebuilder:validation:Optional
	UpgradePolicy []UpgradePolicyParameters `json:"upgradePolicy,omitempty" tf:"upgrade_policy,omitempty"`

	// Whether to wait for the pool to be ready
	// +kubebuilder:validation:Optional
	WaitForPoolReady *bool `json:"waitForPoolReady,omitempty" tf:"wait_for_pool_ready,omitempty"`

	// The zone you want to attach the resource to
	// +kubebuilder:validation:Optional
	Zone *string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type UpgradePolicyObservation struct {
}

type UpgradePolicyParameters struct {

	// The maximum number of nodes to be created during the upgrade
	// +kubebuilder:validation:Optional
	MaxSurge *float64 `json:"maxSurge,omitempty" tf:"max_surge,omitempty"`

	// The maximum number of nodes that can be not ready at the same time
	// +kubebuilder:validation:Optional
	MaxUnavailable *float64 `json:"maxUnavailable,omitempty" tf:"max_unavailable,omitempty"`
}

// PoolSpec defines the desired state of Pool
type PoolSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     PoolParameters `json:"forProvider"`
}

// PoolStatus defines the observed state of Pool.
type PoolStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        PoolObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Pool is the Schema for the Pools API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,scaleway}
type Pool struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              PoolSpec   `json:"spec"`
	Status            PoolStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// PoolList contains a list of Pools
type PoolList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Pool `json:"items"`
}

// Repository type metadata.
var (
	Pool_Kind             = "Pool"
	Pool_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Pool_Kind}.String()
	Pool_KindAPIVersion   = Pool_Kind + "." + CRDGroupVersion.String()
	Pool_GroupVersionKind = CRDGroupVersion.WithKind(Pool_Kind)
)

func init() {
	SchemeBuilder.Register(&Pool{}, &PoolList{})
}
